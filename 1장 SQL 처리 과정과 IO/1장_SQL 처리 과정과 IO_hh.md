### SQL 최적화

- SQL 실행 전 최적화 과정
    
    ① SQL 파싱
    
    - 파싱 트리 생성 : SQL 문을 이루는 개별 구성요소를 분석해서 파싱 트리 생성.
    - Syntax 체크 : 문법적 오류가 없는지 확인.
    - Semantic 체크 : 의미상 오류가 없는지 확인.
        
    
    ② SQL 최적화
    
    - SQL 최적화는 옵티마이저(Optimizer)가 하고, 미리 수집한 시스템 및 오브젝트 통계정보를 바탕으로 다양한 실행경로를 생성해서 비교한 후 가장 효율적인 하나를 선택함.
    - 데이터베이스 성능을 결정하는 가장 핵심적인 엔진.
    
    ③ 로우 소스 생성
    
    - SQL 옵티마이저가 선택한 실행경로를 실제 실행 가능한 코드 또는 프로시저 형태로 포맷팅 하는 단계.
    - 로우 소스 생성기(Row-Source Generator)가 그 역할을 맡음.

<br>

### SQL 옵티마이저

- 사용자가 원하는 작업을 가장 효율적으로 수행할 수 있는 최적의 데이터 액세스 경로를 선택해 주는 DBMS의 핵심 엔진.
- 옵티마이저의 최적화 단계
    
    ① 사용자로부터 전달받은 쿼리를 수행하는 데 후보군이 될만한 실행계획들을 찾아냄.
    
    ② 데이터 딕셔너리(Data Dictionary)에 미리 수집해 둔 오브젝트 통계 및 시스템 통계정보를 이용해 각 실행계획의 예상비용을 산정함.
    
    ③ 최저 비용을 나타내는 실행계획을 선택함.
 
<br> 

### 실행계획과 비용

- 실행계획(Execution Plan) : SQL 옵티마이저가 생성한 처리절차를 사용자가 확인할 수 있게 트리 구조로 표현한 것.
- 미리보기 기능을 통해 자신이 작성한 SQL이 테이블을 스캔하는지 인덱스를 스캔하는지, 인덱스를 스캔한다면 어떤 인덱스인지를 확인할 수 있고, 예상과 다른 방식으로 처리된다면 실행경로를 변경할 수 있음.
- SQL 실행계획에 표시되는 Cost도 어디까지나 예상치이며, 실행경로를 선택하기 위해 옵티마이저가 여러 통계정보를 활용해서 계산해 낸 값.

<br>

### 옵티마이저 힌트

- 옵티마이저 힌트를 이용해 개발자가 직접 더 효율적인 액세스 경로를 찾아낼 수도 있음.
- 힌트 사용법은 주석 기호에 '+'를 붙이면 됨.
    
    ```sql
    SELECT /*+ INDEX(A 고객_PK) */
    		고객명, 연락처, 주소, 가입일시
    FROM 고객A
    WHERE 고객ID = '0000000008';
    ```
    
- 옵티마이저는 주요 경로는 힌트를 주고, 나머지 경로에 대해 옵티마이저의 자율적 판단에 맡길 수 있음. 
- 중대한 시스템이라면, 가끔 실수가 있을 수 있는 옵티마이저의 자율적 판단에 맡길 수는 없으니, 빈틈없이 힌트를 기술해야 함.
    - 옵티마이저가 절대 다른 방식을 선택하지 못하도록 힌트를 빈틈없이 지정함.

<br>

### 소프트 파싱 vs 하드 파싱

- 라이브러리 캐시(Library Cache) : SQL 파싱, 최적화, 로우 소스 생성 과정을 거쳐 생성한 내부 프로시저를 반복 재사용할 수 있도록 캐싱해 두는 메모리 공간.
- SGA(System Global Area) : 서버 프로세스와 백그라운드 프로세스가 공통으로 액세스하는 데이터와제어 구조를 캐싱하는 메모리 공간임.
- 사용자가 SQL 문을 전달하면 DBMS는 SQL을 파싱한 후 해당 SQL이 라이브러리 캐시에 존재하는지부터 확인함.
    - 캐시에서 찾으면 곧바로 실행 단계로 넘어감. → 소프트 파싱(Sot Parsing)
    - 캐시에서 찾지 못하면 최적화 단계를 거쳐, 로우 소스를 생성한 후에 실행 단계로 넘어감. → 하드 파싱(Hard Parsing)
- 라이브 캐시가 필요한 이유
    - 데이터베이스에서 이루어지는 처리 과정은 대부분 I/O 작업에 집중되는 반면, 하드 파싱은 CPU를 많이 소비하는 몇 안 되는 작업 중 하나임.
    - 이렇게 어려운 작업을 거쳐 생성한 내부 프로시저를 한 번만 사용하고 버린다면 비효율적.

<br>

### 데이터베이스 저장 구조
- 테이블스페이스 : 세그먼트를 담는 컨테이너로서, 여러 개의 데이터 파일(디스크 상의 물리적인 OS 파일)로 구성됨.
- 세그먼트 : 데이터 저장공간이 필요한 오브젝트(테이블, 인덱스, 파티션, LOB 등)
- 익스텐트 : 공간을 확장하는 단위. 테이블이나 인덱스에 데이터를 입력하다가 공간이 부족해지면 해당 오브젝트가 속한 테이블스페이스로부터 익스텐트를 추가로 할당 받음.
- 데이터파일 : 디스크 상의 물리적인 OS 파일.
- 블록 : DBMS가 데이터를 읽고 쓰는 단위.

<br>

### 시퀀셜 액세스 vs 랜덤 액세스

① 시퀀셜(Sequential) 액세스 : 논리적 또는 물리적으로 연결된 순서에 따라 차례대로 목록을 읽는 방식.
② 랜덤(Random) 액세스 : 논리적, 물리적인 순서를 따르지 않고, 레코드 하나를 읽기 위해 한 블록씩 접근하는 방식.

<br>

### 논리적 I/O vs 물리적 I/O

- DB 버퍼캐시
    - SQL을 수행하는 과정에서 계속해서 데이터 블록을 읽는데, 자주 읽는 블록을 매번 디스크에서 읽는 것은 매우 비효율적임.
    - 서버 프로세스와 데이터파일 사이에 버퍼캐시가 있으므로 데이터 블록을 읽을 땐 항상 버퍼캐시부터 탐색함.
- 논리적 I/O vs 물리적 I/O
    - 논리적 블록 I/O는 SQL문을 처리하는 과정에 메모리 버퍼캐시에서 발생한 총 블록 I/O를 의미함.
    - 물리적 블록I/O는 디스크에서 발생한 총 블록 I/O를 의미함.
    - 디스크 I/O는 메모리 I/O보다 보통 10,000배쯤 느림.

<br>

### Single Block I/O vs Multiblock I/O

- Single Block I/O : 한 번에 한 블록씩 요청해서 메모리에 적재하는 방식.
    - 인덱스 이용.
- Multiblock I/O : 많은 벽돌을 실어 나를 때 손수레를 이용하는 것처럼 한 번에 여러 블록씩 요청해서 메모리에 적재하는 방식.
    - 인덱스 이용하지 않고 테이블 전체 스캔
- 대용량 테이블을 Full Scan할 Multiblock I/O 단위를 크게 설정하면 성능이 좋아짐.

<br>

### Table Full Scan vs Index Range Scan

- Table Full Scan : 테이블에 속한 블록 전체를 읽어서 사용자가 원하는 데이터를 찾는 방식. 시퀀셜 액세스와 Multiblock I/O 방식.
- Index Range Scan : 인덱스에서 일정량을 스캔하면서 얻은 ROWID로 테이블 레코드를 찾아가는 방식. 랜덤 액세스와 Single Block I/O 방식.

<br>
 
### 캐시 탐색 메커니즘

- 버퍼캐시 탐색 과정을 거치는 오퍼레이션
    - 인덱스 루트 블록을 읽을 때
    - 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
    - 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
    - 인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때
    - 테이블 블록을 Full Scan 할 때
- 버퍼캐시에서 블록을 찾을 때 해시 알고리즘으로 버퍼 해더를 찾고, 거기서 얻은 포인터(Pointer)로 버퍼 블록을 액세스하는 방식으로 사용함.
- 메모리 공유자원에 대한 액세스 직렬화
    - 문제는 하나의 버퍼블록을 두 개 이상의 프로세스가 동시에 접근하려고 할 때 발생함.
        → 한 프로세스에 순차적으로 접근하도록 구현해야 하며, 이를 위해 직렬화(Serialization) 메커니즘이 필요함.
        
<br>       

## 참고자료
[친절한 SQL 튜닝](https://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791196395704)

