* 3-1, 3-2 정리 

### I/O 메커니즘 복습

- DBA(Data Block Address) : 데이터 파일 번호 + 블록번호
- I/O 성능을 높이려면 버퍼캐시를 활용해야 함.
- 해싱 알고리즘으로 버퍼 헤더를 찾고, 거기서 얻은 포인터로 버퍼 블록을 찾아감.
- 인덱스로 테이블 블록을 액세스할 때는 리프 블록에서 읽은 ROWID를 분해해서 DBA 정보를 얻고, 테이블 Full Scan 할 때는 익스텐트 맵을 통해 블록들의 DBA 정보를 얻음.
- ROWID가 가리키는 테이블 블록을 버퍼캐시에서 먼저 찾아보고, 못 찾을 때만 버퍼캐시에 적재한 후에 디스크에서 블록을 읽음.

<br>

### 인덱스 클러스터링 팩터

- 클러스터링 팩터(Clustering Factor, CF) : 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정보를 의미함.
- CF가 좋은 컬럼에 생성한 인덱스는 검색 효율이 좋음. → 데이터 액세스량에 비해 블록 I/O가 적게 발생함을 의미함.
- 버퍼 Pinning :  래치 획득과 해시 체인 스캔 과정을 거쳐 어렵게 찾아간 테이블 블록에 대한 포인터(메모리 주소값)을 바로 해제하지 않고 일단 유지함.
- CF가 안 좋은 인덱스를 사용하면 테이블을 액세스하는 횟수만큼 고스란히 블록 I/O가 발생함.

<br>

### 인덱스 손익분기점

- 인덱스 손익분기점 : Index Range Scan에 의한 테이블 액세스가 Table Full Scan보다 느려지는 지점.
- 인덱스를 이용해 테이블을 액세스할 때는 전체 1,000만 건 중 몇 건을 추출하느냐에 따라 성능이 크게 달라짐.
    - 추출 건수가 많을 수록 느려짐. → 테이블 랜덤 액세스 떄문.
- 인덱스를 이용한 테이블 액세스가 Table Full Scan 보다 느려지게 만드는 핵심적인 두 가지 요인
    1. Table Full Scan은 시퀀셜 액세스인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 랜덤 액세스 방식임.
    2. Table Full Scan은 Multiblock I/O인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 Single Block I/O 방식임.
- CF에 따라 손익분기점이 크게 달라짐.

<br>

### 온라인 프로그램 튜닝 vs 배치 프로그램 튜닝

- 온라인 프로그램 : 온라인 트랜잭션을 처리하는 프로그램
    - 보통 소량 데이터를 읽고 갱신하므로 인덱스를 효과적으로 활용하는 것이 무엇보다 중요함.
- 배치 프로그램 : DW/OLAP/배치 프로그램. 여러 가지 유형이 있지만, 여기서 말하는 배치 프로그램은 대량 데이터를 읽고 가공해서 다른 테이블에 입력하거나, 대량 데이터를 일괄 수정/삭제하는 프로그램.
    - 대량 데이터를 읽고 갱신하는 배치 프로그램은 항상 전체 범위 처리 기준으로 튜인해야 함.

<br>

### 인덱스 컬럼 추가

- 테이블 액세스 최소화를 위해 가장 일반적으로 사용하는 튜닝 기법은 인덱스에 컬럼을 추가하는 것.
- 인덱스 스캔량은 줄지 않지만, 테이블 랜덤 액세스 횟수를 줄여주기 때문.
- 클러스터링 팩터가 좋 인덱스를 이용하면, 테이블 액세스량에 비해 블록 I/O가 훨씬 적게 발생함

<br>

### 인덱스 읽고 처리

- 테이블 액세스 단계 필터 조건에 의해 버려지는 레코드가 많을 때, 인덱스에 컬럼을 추가함으로써 성능 효과를 얻음.
- 성능 개선을 해야 한다면 쿼리에 사용된 컬럼을 모두 인덱스에 추가해서 테이블 액세스가 아예 발생하지 않게 하는 방법을 고려해볼 수 있으나, 추가해야 할 컬럼이 많은 테이블의 경우 실제 적용하기 곤란한 경우도 많음.

<br>

### Include 인덱스

- 인덱스 키 외에 미리 지정한 컬럼을 리프 레벨에 함께 저장하는 기능.

```sql
create index emp_x01 on emp (deptno) include (sal)
```

- emp_x01 인덱스는 SAL 컬럼을 리프 블록에만 저장함.
- 수직적 탐색에는 DEPTNO만 사용하고, 수평적 탐색에는 SAL 컬럼도 필터 조건으로 사용할 수 있음.
- SAL 컬럼은 테이블 랜덤 액세스 횟수를 줄이는 용도.

<br>

### 인덱스 구조 테이블

- IOT(Index-Organized Table) : 랜덤 액세스가 아예 발생하지 않도록 테이블을 인덱스 구조로 생성하는 방법.
- 인덱스 리프 블록이 곧 데이터 블록임.
- IOT는 인위적으로 클러스터링 팩터를 좋게 만드는 방법 중 하나임.

<br>

### 인덱스 클러스터 테이블

- 클러스터 키 값이 같은 레코드를 한 블록에 모아서 저장하는 구조.
- 한 블록에 모두 담을 수 없을 때는 새로운 블록을 할당해서 클러스터 체인으로 연결함.
- 일반 테이블에 생성한 인덱스 레코드는 테이블 레코드와 1:1 대응 관계를 갖지만, 클러스터 인덱스는 테이블 레코드와 1:M 관계를 가짐.
- 클러스터 인덱스의 키 값은 항상 Unique 함. → 중복값이 없음.

<br>

### 부분범위 처리

- DBMS가 클라이언트에게 데이터를 전송할 때도 일정량을 나눠서 전송하며, 전체 결과 집합 중 아직 전송하지 않은 분량이 많이 남아있어도 서버 프로세스는 클라이언트로부터 추가 Fetch Call을 받기 전까지 그대로 멈춰 서서 기다림.
- OLTP 환경에서 대용량 데이터를 빠르게 핸들링할 수 있는 아주 중요한 원리가 바로 이것.

<br>

### Array Size 조정을 통한 Fetch call 최소화

- 대량 데이터를 파일로 내려받는다면 어차피 데이터를 모두 전송해야 하므로 가급적 그 값을 크게 설정해야 함.
- Array Size를 조정한다고 해서 전송해야 할 총량이 변하진 않지만, Fetch call 횟수를 그만큼 줄일 수 있음.
