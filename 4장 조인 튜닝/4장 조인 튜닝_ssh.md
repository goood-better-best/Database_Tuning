# 4장 조인 튜닝





# 4.1 NL 조인

- 조인의 기본은 NL 조인
  - NL조인은 인덱스를 이용한 조인 방법



## 4.1.1 기본 메커니즘

- 상황
  - 사원과 고객테이블이 있을때 1996년 1월 1일 이후 입사한 사원이 관리하는 고객 데이터를 추출하는 프로그램



```sql
select e.사원명, c.고객명, c.전화번호
from 사원 e, 고객 c
where e.입사일자 >= '19960101'
and c.관리사원번호 = e.사원번호
```



- 가장 쉽게 구현하는 방법은 사원 테이블에서 1996년 1월 1일 이후 입사자를 찾아 고객 테이블에서 사원번호가 일치하는 고객 데이터를 하나하나 추출하는 것
  - 이것이 바로 Nested Loop 조인이 사용하는 알고리즘이다.
    1. 사원_X1 인덱스에서 입사일자 >= '19960101' 인 첫번 째 레코드를 찾는다.
    2. 인덱스에서 읽은 ROWID로 사원 테이블 레코드를 찾는다.
    3. 사원 테이블에서 읽은 사원번호 '0006'으로 고객_X1 인덱스를 탐색함
    4. 고객_X1 인덱스에서 읽은 ROWID로 고객 테이블 레코드를 찾아감
    5. 고객_X1 인덱스에서 한 건 더 스캔하고 관리사원 번호가 '0006'인지 확인함
    6. 이후 고객 인덱스 스캔을 멈출 때 까지(사원번호가 0006이 아닌 값이 나올 때 까지) 반복 후 다시 사원_X1 인덱스에서 똑같은 LOOP 진행



  

## 4.1.2 NL 조인 실행계획 제어

- NL 조인 실행 계획

```sql
Execution Plan
-------------------------------------------------------
0     SELECT STATEMENT Optimizer = ALL_ROWS
1  0    NESTED LOOPS
2  1      TABLE ACCESS (BY INDEX ROWID) OF '사원' (TABLE)
3  2		INDEX (RANGE SCAN) OF '사원_X1' (INDEX)
4  1	  TABLE ACCESS (BY INDEX ROWID) OF '고객' (TABLE)
5  4		INDEX (RANGE SCAN) OF '고객_X1' (INDEX)
```

- NL 조인 제어시 use_nl 힌트 사용

```sql
select /*+ ordered use_nl(C) */
		e.사원명, c.고객명, c.전화번호
from 사원 e, 고객 c
where e.입사일자 >= '19960101'
and   c.관리사원번호 = e. 사원번호
```

  

  

- 세개 이상 테이블을 조인할 때 힌트 사용 법

```sql
select /*+ ordered use_nl(B) use_nl(C) use_hash(D) */ *
from A, B, C, d
where ...
```

A -> B -> C -> D 순으로 조인하되, B, C와 조인할 때는 NL방식으로 D와 조인할 때는 해시 방식으로 조인하라는 의미





## 4.1.3 NL 조인 수행 과정 분석

- 자세한 NL 수행 과정 분석을 위한 조건절 추가

```sql
select /*+ ordered use_nl(C) index(e) index(c) */
		e.사원번호, e.사원명, e.입사일자
		c.고객번호, c.고객명, c.전화번호, c.최종주문금액
from 사원 e, 고객 c
where c.관리사원번호 = e. 사원 번호  #1
and   e.입사일자    >= '19960101'  #2
and   e.부서코드     = "Z123"      #3
and   c.최종주문금액 >= 20000       #4
```

```
인덱스 구성
* 사원_PK : 사원번호
* 사원_X1 : 입사일자
* 고객_PK : 고객번호
* 고객_X1 : 관리사원번호
* 고객_X2 : 최종주문금액
```



- 두 테이블에 index 힌트를 명시했으므로 인덱스를 사용하여 액세스 시도
  - 인덱스명은 명시하지 않았으므로 optimizer가 결정하여 알아서 사용함

  

- 조건절 비교 순서를 따져보면 e에서 c쪽으로 join이 이루어지기 때문에 #2, #3 조건절을 처리하고 #1 #4 조건절의 처리를 하게 될 것이다.
  - 여기서 중요한건, 각 단계를 모두 완료하고 다음 단계로 넘어가는 것이 아닌, 한 레코드씩 순차적으로 진행한다는 것이다.

  

  

## 4.1.4 NL 조인 튜닝 포인트

- 만약 부서코드(Z123)으로 필터링 되는 비율이 많다면 인덱스에 부서코드를 넣어야 한다.
- 사원 테이블을 읽고 필터링한 결과 건수에 비례해 고객_X1 인덱스와의 조인시도 횟수가 달라지게 된다.
  - 이 조인시도 횟수가 많아질 수록 성능이 낮아질 것이다.
- 고객_X1 인덱스를 읽고 나서 고객 테이블을 액세스 할 때 최종주문금액에 의해 필터링 되는 비율이 높으면 X1인덱스에 최종주문 금액 컬럼을 추가하는 방안을 고려해야함
- 맨 처음 액세스하는 사원_X1 인덱스에서 얻은 결과 건수에 의해 전체 일량이 좌우될 것이다.

  

  

### 올바른 조인 메소드 선택

- 온라인 트랜잭션 처리(OLTP) 시스템에서 튜닝할 떄는 일차적으로 NL조인부터 고려하는 것이 올바른 순서다.

  

  

## 4.1.5 NL 조인 특징 요약

- 랜덤 액세스 위주의 조인 방식
- 한 레코드씩 순차적으로 진행함



  

# 4.2 소트 머지 조인

- 조인 컬럼에 인덱스가 없을 때, 대량 데이터 조인이어서 인덱스가 효과적이지 않을 때, 옵티마이저는 NL 조인 대신 소트 머지 조인이나 해시 조인을 선택함
- 해시 조인의 등장으로 소트 머지 조인의 쓰임새가 예전만하진 않다.
- 해시 조인을 사용할 수 없는 상황에서 대량 데이터를 조인하고자 할때 유용하다.
  - 해시 조인을 사용할 수 없는 상황은?
    - 조인 조건식이 등치(=) 조건이 아닐때 사용할 수 없음

  

- 소트 머지 조인과 해시 조인을 이해하려면 PGA에 대한 이해가 필요하다.

## 4.2.1 SGA vs PGA

- SGA는 공유 메모리 영역

  - 여기 있는 데이터에 접근하려면 버퍼 Lock도 얻어야함

    

- 각 오라클 서버 프로세스에 할단된 메모리 영역을 PGA라고 부른다.

  - 프로세스에 종속적인 고유 데이터를 저장하는 용도로 사용함
  - 할당받은 PGA 공간이 작아 데이터를 모두 저장할 수 없을 때는 Temp 테이블 스페이스 이용
  - 래치 매커니즘이 필요없어서 SGA보다 속도 빠름

  



## 4.2.2 기본 메커니즘

- 소트 머지 조인은 이름처럼 두 단계로 진행됨
  - 소트 단계(sort) :  양쪽 집한은 조인 컬럼 기준으로 정렬
  - 머지 단계(merge) : 정렬한 양쪽 집한을 서로 merge 함 

 

```sql
select /*+ ordered use_merge(c) */
		e.사원번호, e.사원명, e.입사일자
		c.고객번호, c.고객명, c.전화번호, c.최종주문금액
from 사원 e, 고객 c
where c.관리사원번호 = e. 사원 번호  #1
and   e.입사일자    >= '19960101'  #2
and   e.부서코드     = "Z123"      #3
and   c.최종주문금액 >= 20000       #4
```



- 수행 과정
  - #2, #3에 해당하는 사원 데이터를 읽어 조인컬럼인 사원번호 순으로 정렬 -- 소트 단계
  - 정렬한 결과집합은 PGA 영역에 할당된 Sort Area에 저장
  - #4에 해당하는 고객 데이터를 정렬하여 PGA 영역의 Sort Area에 저장 -- 소트 단계
  - PGA에 저장한 사원데이터를 스캔하면서 PGA에 저장한 고객 데이터와 조인 -- 머지 단계



  

### 4.2.3 소트 머지 조인이 빠른이유

- NL 조인의 치명적인 단점은 대량 데이터 조인할 때 성능이 매우 느리다는 것
  - 모든 건을 DB 버퍼 캐시(SGA에 있는)를 경유하기 때문에 느림

  

- 반명 소트 머지 조인은 양쪽 테이블로부터 조인 대상 집합을 일괄적으로 읽어와 PGA에서 작업하기 때문에 NL 조인보다 유리하다.

​    

  

## 4.2.4 소트 머지 조인의 주용도

- 해시 조인은 조인 조건식이 등치조건이 아닐때 사용 할 수 없다.
- 그래서 소트 머지조인은 아래와 같은 사용에서 사용함
  - 조인 조건식이 등치조건이 아닌 대량 데이터 조인
  - 조인 조건식이 아예 없는 조인(cross join, 카테시안 곱)

  

  

# 4.3 해시 조인

- NL 조인은 인덱스를 이용한 조인 방식이라서 인덱스 구성에 따른 성능 차이가 심함

  - 인덱스를 아무리 완벽하게 구성해도 랜덤 I/O 때문에 대량 데이터 처리에 불리하고

    버퍼캐시 히트율에 따라 들쭉날쭉한 성능을 보임

- 소트 머지 조인과 해시 조인은 조인 과정에 인덱스를 사용하지 않기 때문에 대량 데이터 조인시 NL 조인보다 훨씬 빠르고 일정한 성능을 보임

- 소트 머지 조인은 항상 양쪽 테이블을 정렬해야하는 부담이 있는데 해시 조인은 그런 부담이 없음

  

  

## 4.3.1 기본 메커니즘

- 해시 조인도 소트 머지 조인처럼 두 단계로 진행
  - Build 단계 : 작은 쪽 테이블(Build Input)을 읽어 해시 테이블(해시 맵)을 생성
  - Probe 단계 : 큰 쪽 테이블 (Probe input)을 읽어 해시 테이블을 탐색하면서 조인



  

```sql
select /*+ ordered use_hash(c) */
		e.사원번호, e.사원명, e.입사일자
		c.고객번호, c.고객명, c.전화번호, c.최종주문금액
from 사원 e, 고객 c
where c.관리사원번호 = e. 사원 번호  #1
and   e.입사일자    >= '19960101'  #2
and   e.부서코드     = "Z123"      #3
and   c.최종주문금액 >= 20000       #4
```



1. Build 단계 : #2, #3에 해당하는 사원 데이터를 읽어 해시 테이블을 생성한다.

   ​					이때, 조인컬럼인 사원번호를 해시 테이블 키 값으로 사용

   ​					사원번호를 해시 함수에 입력해서 반환된 값으로 해시 체인을 찾고, 그 해시 체인에 데이터를 연결한다.

   ​					해시 테이블은 PGA 영역에 할당된 Hash Area에 저장한다.



2.  Probe 단계 : #4 조건에 해당하는 고객 데이터를 하나씩 읽어 앞서 생성한 해시 테이블을 탐색한다.

   ​						즉, 관리사원번호를 해시 함수에 입력해서 반환된 값으로 해시 체인을 찾고

   ​						그 해시 체인을 스캔해서 값이 같은 사원번호를 찾는다.

   ​						찾으면 조인에 성공한 것이고, 못찾으면 실패한 것

  

## 4.3.2 해시 조인이 빠른 이유

- Hash Area에 생성한 해시 테이블을 이용한다는 점만 다를 뿐 해시 조인도 조인 프로세싱 자체는 NL 조인과 같다.

  - 그러나 PGA를 사용하기 때문에 NL보다는 빠르다.

  - NL조인처럼 조인 과정에서 발생하는 랜덤 액세스 부하가 없고

    소트 머지 조인처럼 양쪽 집합을 미리 정렬하는 부하도 없다.

  - 만약 대용량 데이터인 경우에는 Divide & Conquer 방식으로 진행



  

## 4.3.5 조인 메소드 선택 기준

- 소량 데이터 조인 -> NL 조인
- 대량 데이터 조인 -> Hash 조인
- 대량 데이터지만 등치 조건이 아닌 경우 -> Sort Merger 조인

  

- 소량 데이터 / 대량 데이터의 기준
  - NL 조인 기준으로 최적화를 했지만 성능 개선이 되지 않는 데이터의 양

  

- 수행 빈도가 높은 쿼리라면?
  - (최적화된) NL 조인과 해시 조인 성능이 같으면 NL 조인
  - 해시 조인이 갸간 더 빨라도 NL 조인
  - NL 조인보다 해시 조인이 매우 빠른 경우, 해시 조인



  

- NL 조인에서 사용하는 인덱스는 영구적으로 유지하며 다양하게 사용되지만

  해시나 소트 머지의 경우 개별로 사용되기때문에 NL 조인 사용을 항상 염두에 두어야 한다.

  

  

